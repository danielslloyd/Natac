<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delaunay Triangulation Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        #controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            background: #4CAF50;
            color: white;
            border-radius: 3px;
        }
        button:hover {
            background: #45a049;
        }
        canvas {
            background: white;
            border: 1px solid #ccc;
            display: block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="generatePoints('poisson')">Generate Poisson-Disc Points</button>
        <button onclick="generatePoints('hex')">Generate Hex Grid Points</button>
        <br><br>
        <button onclick="generateMap('hex-standard')">Hex Standard Map (1+6+12 tiles)</button>
        <button onclick="generateMap('hex-expanded')">Hex Expanded Map (N tiles)</button>
        <button onclick="generateMap('delaunay-expanded')">Delaunay Expanded Map (N tiles)</button>
        <label>N = <input type="number" id="numTiles" value="30" min="1" max="200" style="width: 60px;"></label>
    </div>
    <canvas id="canvas" width="1200" height="800"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const margin = 20;

        // Bounding box
        const bounds = {
            x: margin,
            y: margin,
            width: width - 2 * margin,
            height: height - 2 * margin
        };

        let points = [];
        let triangles = [];
        let tileNeighbors = [];
        let voronoiVertices = []; // circumcenters (blue nodes)
        let voronoiEdges = []; // green lines
        let tiles = []; // tile data for each red point
        let validTiles = new Set(); // tiles with complete Voronoi cells
        let edgeTiles = new Set(); // tiles on boundary
        let currentPointType = 'hex';

        // Poisson-disc sampling
        function poissonDiscSampling(numPoints) {
            const minDistance = Math.sqrt((bounds.width * bounds.height) / numPoints) * 0.8;
            const cellSize = minDistance / Math.sqrt(2);
            const gridWidth = Math.ceil(bounds.width / cellSize);
            const gridHeight = Math.ceil(bounds.height / cellSize);
            const grid = new Array(gridWidth * gridHeight).fill(null);
            const active = [];
            const points = [];

            function getGridIndex(x, y) {
                const col = Math.floor((x - bounds.x) / cellSize);
                const row = Math.floor((y - bounds.y) / cellSize);
                return row * gridWidth + col;
            }

            function isValid(x, y) {
                if (x < bounds.x || x >= bounds.x + bounds.width ||
                    y < bounds.y || y >= bounds.y + bounds.height) {
                    return false;
                }

                const col = Math.floor((x - bounds.x) / cellSize);
                const row = Math.floor((y - bounds.y) / cellSize);

                for (let r = Math.max(0, row - 2); r <= Math.min(gridHeight - 1, row + 2); r++) {
                    for (let c = Math.max(0, col - 2); c <= Math.min(gridWidth - 1, col + 2); c++) {
                        const idx = r * gridWidth + c;
                        if (grid[idx] !== null) {
                            const other = grid[idx];
                            const dx = x - other[0];
                            const dy = y - other[1];
                            if (Math.sqrt(dx * dx + dy * dy) < minDistance) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            // Start with random point
            const startX = bounds.x + Math.random() * bounds.width;
            const startY = bounds.y + Math.random() * bounds.height;
            const start = [startX, startY];
            points.push(start);
            active.push(start);
            grid[getGridIndex(startX, startY)] = start;

            // Generate points
            while (active.length > 0 && points.length < numPoints) {
                const idx = Math.floor(Math.random() * active.length);
                const point = active[idx];
                let found = false;

                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = minDistance + Math.random() * minDistance;
                    const x = point[0] + radius * Math.cos(angle);
                    const y = point[1] + radius * Math.sin(angle);

                    if (isValid(x, y)) {
                        const newPoint = [x, y];
                        points.push(newPoint);
                        active.push(newPoint);
                        grid[getGridIndex(x, y)] = newPoint;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    active.splice(idx, 1);
                }
            }

            return points;
        }

        // Hex grid generation
        function generateHexGrid(numPoints) {
            const points = [];
            const area = bounds.width * bounds.height;
            const spacing = Math.sqrt(area / numPoints) * 1.1;
            const rowHeight = spacing * Math.sqrt(3) / 2;

            let row = 0;
            for (let y = bounds.y; y < bounds.y + bounds.height && points.length < numPoints; y += rowHeight) {
                const offset = (row % 2) * spacing / 2;
                for (let x = bounds.x + offset; x < bounds.x + bounds.width && points.length < numPoints; x += spacing) {
                    if (x >= bounds.x && x <= bounds.x + bounds.width &&
                        y >= bounds.y && y <= bounds.y + bounds.height) {
                        points.push([x, y]);
                    }
                }
                row++;
            }

            return points.slice(0, numPoints);
        }

        // Delaunay triangulation (Bowyer-Watson algorithm)
        function delaunay(points) {
            if (points.length < 3) return [];

            // Create super-triangle that contains all points
            const minX = Math.min(...points.map(p => p[0])) - 1000;
            const minY = Math.min(...points.map(p => p[1])) - 1000;
            const maxX = Math.max(...points.map(p => p[0])) + 1000;
            const maxY = Math.max(...points.map(p => p[1])) + 1000;

            const superTriangle = [
                [minX, minY],
                [maxX, minY],
                [(minX + maxX) / 2, maxY]
            ];

            let triangles = [[0, 1, 2]];
            const vertices = [...superTriangle, ...points];

            // Add points one at a time
            for (let i = 0; i < points.length; i++) {
                const pointIdx = i + 3; // Offset by super-triangle vertices
                const point = vertices[pointIdx];
                const badTriangles = [];

                // Find triangles whose circumcircle contains the point
                for (let j = 0; j < triangles.length; j++) {
                    const tri = triangles[j];
                    const [ax, ay] = vertices[tri[0]];
                    const [bx, by] = vertices[tri[1]];
                    const [cx, cy] = vertices[tri[2]];

                    if (inCircumcircle(point[0], point[1], ax, ay, bx, by, cx, cy)) {
                        badTriangles.push(j);
                    }
                }

                // Find boundary edges
                const polygon = [];
                for (const triIdx of badTriangles) {
                    const tri = triangles[triIdx];
                    const edges = [[tri[0], tri[1]], [tri[1], tri[2]], [tri[2], tri[0]]];

                    for (const edge of edges) {
                        let shared = false;
                        for (const otherTriIdx of badTriangles) {
                            if (otherTriIdx === triIdx) continue;
                            const otherTri = triangles[otherTriIdx];
                            if (hasEdge(otherTri, edge[0], edge[1])) {
                                shared = true;
                                break;
                            }
                        }
                        if (!shared) {
                            polygon.push(edge);
                        }
                    }
                }

                // Remove bad triangles
                for (let j = badTriangles.length - 1; j >= 0; j--) {
                    triangles.splice(badTriangles[j], 1);
                }

                // Add new triangles
                for (const edge of polygon) {
                    triangles.push([edge[0], edge[1], pointIdx]);
                }
            }

            // Remove triangles that share vertices with super-triangle
            triangles = triangles.filter(tri =>
                tri[0] >= 3 && tri[1] >= 3 && tri[2] >= 3
            );

            // Adjust indices (remove super-triangle offset)
            triangles = triangles.map(tri =>
                tri.map(idx => idx - 3)
            );

            return { triangles, vertices: points };
        }

        function inCircumcircle(px, py, ax, ay, bx, by, cx, cy) {
            const ax_ = ax - px;
            const ay_ = ay - py;
            const bx_ = bx - px;
            const by_ = by - py;
            const cx_ = cx - px;
            const cy_ = cy - py;

            return (
                (ax_ * ax_ + ay_ * ay_) * (bx_ * cy_ - cx_ * by_) -
                (bx_ * bx_ + by_ * by_) * (ax_ * cy_ - cx_ * ay_) +
                (cx_ * cx_ + cy_ * cy_) * (ax_ * by_ - bx_ * ay_)
            ) > 0;
        }

        function hasEdge(tri, a, b) {
            return (tri.includes(a) && tri.includes(b));
        }

        // Calculate triangle circumcenter (Voronoi vertex)
        function getCircumcenter(p1, p2, p3) {
            const [ax, ay] = p1;
            const [bx, by] = p2;
            const [cx, cy] = p3;

            const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
            if (Math.abs(d) < 1e-10) {
                // Degenerate triangle, return centroid
                return [(ax + bx + cx) / 3, (ay + by + cy) / 3];
            }

            const ux = ((ax * ax + ay * ay) * (by - cy) + (bx * bx + by * by) * (cy - ay) + (cx * cx + cy * cy) * (ay - by)) / d;
            const uy = ((ax * ax + ay * ay) * (cx - bx) + (bx * bx + by * by) * (ax - cx) + (cx * cx + cy * cy) * (bx - ax)) / d;

            return [ux, uy];
        }

        // Find neighboring triangles (share an edge) - for nodes
        function findNeighbors(triangles) {
            const neighbors = triangles.map(() => []);

            for (let i = 0; i < triangles.length; i++) {
                const tri1 = triangles[i];
                const edges1 = [
                    [tri1[0], tri1[1]],
                    [tri1[1], tri1[2]],
                    [tri1[2], tri1[0]]
                ];

                for (let j = i + 1; j < triangles.length; j++) {
                    const tri2 = triangles[j];

                    // Check if triangles share an edge
                    for (const edge of edges1) {
                        if (hasEdge(tri2, edge[0], edge[1])) {
                            neighbors[i].push(j);
                            neighbors[j].push(i);
                            break;
                        }
                    }
                }
            }

            return neighbors;
        }

        // Build Voronoi diagram and tile structure
        function buildVoronoi(points, triangles) {
            // Calculate circumcenters
            voronoiVertices = [];
            for (const tri of triangles) {
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];
                voronoiVertices.push(getCircumcenter(p1, p2, p3));
            }

            // Find triangle neighbors (share an edge)
            const triangleNeighbors = findNeighbors(triangles);

            // Build Voronoi edges (green lines)
            voronoiEdges = [];
            for (let i = 0; i < triangles.length; i++) {
                for (const j of triangleNeighbors[i]) {
                    if (j > i) { // Each edge only once
                        voronoiEdges.push([i, j]);
                    }
                }
            }

            // Build tiles: for each point, find all triangles containing it
            tiles = [];
            tileNeighbors = [];
            validTiles = new Set();
            edgeTiles = new Set();

            for (let i = 0; i < points.length; i++) {
                // Find all triangles containing point i
                const trianglesWithPoint = [];
                for (let t = 0; t < triangles.length; t++) {
                    if (triangles[t].includes(i)) {
                        trianglesWithPoint.push(t);
                    }
                }

                tiles.push(trianglesWithPoint);

                // Find neighbors: points connected by Delaunay edges
                const neighbors = new Set();
                for (const t of trianglesWithPoint) {
                    for (const v of triangles[t]) {
                        if (v !== i) {
                            neighbors.add(v);
                        }
                    }
                }
                tileNeighbors.push(Array.from(neighbors));

                // Check if tile is complete
                // A complete tile has a Voronoi vertex for each neighbor
                // This means all the triangles form a closed ring around the point
                if (trianglesWithPoint.length === neighbors.size && trianglesWithPoint.length >= 3) {
                    validTiles.add(i);

                    // Check if it's an edge tile (has fewer than expected neighbors for the grid type)
                    // For now, mark tiles with < 6 neighbors as edge tiles (hex grid assumption)
                    if (neighbors.size < 6) {
                        edgeTiles.add(i);
                    }
                } else {
                    edgeTiles.add(i); // Incomplete tiles are edge tiles
                }
            }
        }

        // Find center tile (closest to canvas center)
        function findCenterTile() {
            const cx = width / 2;
            const cy = height / 2;
            let minDist = Infinity;
            let centerIdx = 0;

            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i) || edgeTiles.has(i)) continue;
                const dx = points[i][0] - cx;
                const dy = points[i][1] - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    centerIdx = i;
                }
            }

            return centerIdx;
        }

        // Main generation and drawing function
        function generatePoints(type) {
            currentPointType = type;
            ctx.clearRect(0, 0, width, height);

            // Generate points
            if (type === 'poisson') {
                points = poissonDiscSampling(500);
            } else {
                points = generateHexGrid(500);
            }

            if (points.length < 3) {
                alert('Not enough points generated!');
                return;
            }

            // Compute Delaunay triangulation
            const result = delaunay(points);
            triangles = result.triangles;

            if (triangles.length === 0) {
                alert('Triangulation failed!');
                return;
            }

            // Build Voronoi diagram and tile structure
            buildVoronoi(points, triangles);

            // Draw black lines (Delaunay edges)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.5;
            for (const tri of triangles) {
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.lineTo(p3[0], p3[1]);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw green lines (Voronoi edges / tile boundaries)
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1.5;
            for (const edge of voronoiEdges) {
                const v1 = voronoiVertices[edge[0]];
                const v2 = voronoiVertices[edge[1]];
                ctx.beginPath();
                ctx.moveTo(v1[0], v1[1]);
                ctx.lineTo(v2[0], v2[1]);
                ctx.stroke();
            }

            // Draw blue circles (Voronoi vertices / tile corners)
            ctx.fillStyle = 'blue';
            for (const vertex of voronoiVertices) {
                ctx.beginPath();
                ctx.arc(vertex[0], vertex[1], 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw red circles (tile centers)
            // Valid tiles = solid red, invalid/edge tiles = red with yellow outline
            for (let i = 0; i < points.length; i++) {
                const point = points[i];

                if (!validTiles.has(i)) {
                    // Invalid tile - yellow circle
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (edgeTiles.has(i)) {
                    // Edge tile - orange circle
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Draw the center point
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Generate map with land and water tiles
        function generateMap(mode) {
            if (triangles.length === 0) {
                alert('Please generate points first!');
                return;
            }

            const centerTile = findCenterTile();
            const landTiles = new Set();
            const numTiles = parseInt(document.getElementById('numTiles').value);

            if (mode === 'hex-standard') {
                // Center + 6 neighbors + 12 neighbors
                landTiles.add(centerTile);

                // Add first ring (6 neighbors)
                const ring1 = tileNeighbors[centerTile].filter(t => validTiles.has(t) && !edgeTiles.has(t));
                ring1.forEach(t => landTiles.add(t));

                // Add second ring (12 neighbors)
                const ring2 = new Set();
                ring1.forEach(t => {
                    tileNeighbors[t].forEach(n => {
                        if (!landTiles.has(n) && validTiles.has(n) && !edgeTiles.has(n)) {
                            ring2.add(n);
                        }
                    });
                });
                ring2.forEach(t => landTiles.add(t));

            } else if (mode === 'hex-expanded' || mode === 'delaunay-expanded') {
                // Random propagation from center (excluding edge tiles)
                landTiles.add(centerTile);
                const frontier = [centerTile];

                while (landTiles.size < numTiles && frontier.length > 0) {
                    const randomIdx = Math.floor(Math.random() * frontier.length);
                    const current = frontier[randomIdx];
                    frontier.splice(randomIdx, 1);

                    // Get valid neighbors (non-edge tiles only)
                    let neighbors = tileNeighbors[current].filter(n =>
                        validTiles.has(n) && !edgeTiles.has(n)
                    );

                    // Shuffle and add neighbors
                    const shuffled = neighbors.sort(() => Math.random() - 0.5);
                    for (const neighbor of shuffled) {
                        if (!landTiles.has(neighbor) && landTiles.size < numTiles) {
                            landTiles.add(neighbor);
                            frontier.push(neighbor);
                        }
                    }
                }
            }

            // Determine water tiles (neighbors of land tiles)
            const waterTiles = new Set();
            landTiles.forEach(tile => {
                tileNeighbors[tile].forEach(neighbor => {
                    if (!landTiles.has(neighbor) && validTiles.has(neighbor)) {
                        waterTiles.add(neighbor);
                    }
                });
            });

            // Redraw everything with colors
            ctx.clearRect(0, 0, width, height);

            // Draw tiles (Voronoi cells) with fill colors
            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i) || tiles[i].length < 3) continue;

                // Get the tile's vertices (circumcenters of triangles containing this point)
                const tileVertices = tiles[i].map(t => voronoiVertices[t]);

                // Order vertices around the center point
                const center = points[i];
                tileVertices.sort((a, b) => {
                    const angleA = Math.atan2(a[1] - center[1], a[0] - center[0]);
                    const angleB = Math.atan2(b[1] - center[1], b[0] - center[0]);
                    return angleA - angleB;
                });

                // Determine color
                if (landTiles.has(i)) {
                    ctx.fillStyle = 'rgba(34, 139, 34, 0.5)'; // Green land
                } else if (waterTiles.has(i)) {
                    ctx.fillStyle = 'rgba(30, 144, 255, 0.5)'; // Blue water
                } else {
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; // Gray void
                }

                // Draw the tile polygon
                ctx.beginPath();
                ctx.moveTo(tileVertices[0][0], tileVertices[0][1]);
                for (let j = 1; j < tileVertices.length; j++) {
                    ctx.lineTo(tileVertices[j][0], tileVertices[j][1]);
                }
                ctx.closePath();
                ctx.fill();
            }

            // Draw black lines (Delaunay edges)
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.5;
            for (const tri of triangles) {
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.lineTo(p3[0], p3[1]);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw green lines (Voronoi edges / tile boundaries)
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1.5;
            for (const edge of voronoiEdges) {
                const v1 = voronoiVertices[edge[0]];
                const v2 = voronoiVertices[edge[1]];
                ctx.beginPath();
                ctx.moveTo(v1[0], v1[1]);
                ctx.lineTo(v2[0], v2[1]);
                ctx.stroke();
            }

            // Draw blue circles (Voronoi vertices / tile corners)
            ctx.fillStyle = 'blue';
            for (const vertex of voronoiVertices) {
                ctx.beginPath();
                ctx.arc(vertex[0], vertex[1], 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw red circles (tile centers)
            for (let i = 0; i < points.length; i++) {
                const point = points[i];

                if (!validTiles.has(i)) {
                    // Invalid tile - yellow circle
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (edgeTiles.has(i)) {
                    // Edge tile - orange circle
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Draw the center point
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Initialize with hex grid
        generatePoints('hex');
    </script>
</body>
</html>
