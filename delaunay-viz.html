<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delaunay Triangulation Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        #controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            background: #4CAF50;
            color: white;
            border-radius: 3px;
        }
        button:hover {
            background: #45a049;
        }
        canvas {
            background: white;
            border: 1px solid #ccc;
            display: block;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="generatePoints('poisson')">Generate Poisson-Disc Points</button>
        <button onclick="generatePoints('hex')">Generate Hex Grid Points</button>
        <br><br>
        <label>Min Angle (deg): <input type="number" id="minAngle" value="20" min="0" max="60" style="width: 50px;"></label>
        <label>Lloyd Relaxation: <input type="checkbox" id="lloydRelaxation" checked></label>
        <br><br>
        <button onclick="generateMap('hex-standard')">Hex Standard Map (1+6+12 tiles)</button>
        <button onclick="generateMap('hex-expanded')">Hex Expanded Map (N tiles)</button>
        <button onclick="generateMap('delaunay-expanded')">Delaunay Expanded Map (N tiles)</button>
        <br>
        <label>N = <input type="number" id="numTiles" value="30" min="1" max="200" style="width: 60px;"></label>
        <label>Y (erosion rounds) = <input type="number" id="erosionRounds" value="5" min="0" max="50" style="width: 50px;"></label>
    </div>
    <canvas id="canvas" width="1200" height="800"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const margin = 20;

        // Bounding box
        const bounds = {
            x: margin,
            y: margin,
            width: width - 2 * margin,
            height: height - 2 * margin
        };

        let points = [];
        let triangles = [];
        let tileNeighbors = [];
        let voronoiVertices = []; // centroids (blue nodes)
        let voronoiEdges = []; // green lines
        let tiles = []; // tile data for each red point
        let validTiles = new Set(); // tiles with complete Voronoi cells
        let edgeTiles = new Set(); // tiles on boundary
        let ineligibleTiles = new Set(); // tiles ineligible for land propagation
        let validTriangles = new Set(); // triangles that pass angle threshold
        let currentPointType = 'hex';

        // Poisson-disc sampling
        function poissonDiscSampling(numPoints) {
            const minDistance = Math.sqrt((bounds.width * bounds.height) / numPoints) * 0.8;
            const cellSize = minDistance / Math.sqrt(2);
            const gridWidth = Math.ceil(bounds.width / cellSize);
            const gridHeight = Math.ceil(bounds.height / cellSize);
            const grid = new Array(gridWidth * gridHeight).fill(null);
            const active = [];
            const points = [];

            function getGridIndex(x, y) {
                const col = Math.floor((x - bounds.x) / cellSize);
                const row = Math.floor((y - bounds.y) / cellSize);
                return row * gridWidth + col;
            }

            function isValid(x, y) {
                if (x < bounds.x || x >= bounds.x + bounds.width ||
                    y < bounds.y || y >= bounds.y + bounds.height) {
                    return false;
                }

                const col = Math.floor((x - bounds.x) / cellSize);
                const row = Math.floor((y - bounds.y) / cellSize);

                for (let r = Math.max(0, row - 2); r <= Math.min(gridHeight - 1, row + 2); r++) {
                    for (let c = Math.max(0, col - 2); c <= Math.min(gridWidth - 1, col + 2); c++) {
                        const idx = r * gridWidth + c;
                        if (grid[idx] !== null) {
                            const other = grid[idx];
                            const dx = x - other[0];
                            const dy = y - other[1];
                            if (Math.sqrt(dx * dx + dy * dy) < minDistance) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            // Start with random point
            const startX = bounds.x + Math.random() * bounds.width;
            const startY = bounds.y + Math.random() * bounds.height;
            const start = [startX, startY];
            points.push(start);
            active.push(start);
            grid[getGridIndex(startX, startY)] = start;

            // Generate points
            while (active.length > 0 && points.length < numPoints) {
                const idx = Math.floor(Math.random() * active.length);
                const point = active[idx];
                let found = false;

                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = minDistance + Math.random() * minDistance;
                    const x = point[0] + radius * Math.cos(angle);
                    const y = point[1] + radius * Math.sin(angle);

                    if (isValid(x, y)) {
                        const newPoint = [x, y];
                        points.push(newPoint);
                        active.push(newPoint);
                        grid[getGridIndex(x, y)] = newPoint;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    active.splice(idx, 1);
                }
            }

            return points;
        }

        // Hex grid generation
        function generateHexGrid(numPoints) {
            const points = [];
            const area = bounds.width * bounds.height;
            const spacing = Math.sqrt(area / numPoints) * 1.1;
            const rowHeight = spacing * Math.sqrt(3) / 2;

            let row = 0;
            for (let y = bounds.y; y < bounds.y + bounds.height && points.length < numPoints; y += rowHeight) {
                const offset = (row % 2) * spacing / 2;
                for (let x = bounds.x + offset; x < bounds.x + bounds.width && points.length < numPoints; x += spacing) {
                    if (x >= bounds.x && x <= bounds.x + bounds.width &&
                        y >= bounds.y && y <= bounds.y + bounds.height) {
                        points.push([x, y]);
                    }
                }
                row++;
            }

            return points.slice(0, numPoints);
        }

        // Delaunay triangulation (Bowyer-Watson algorithm)
        function delaunay(points) {
            if (points.length < 3) return [];

            // Create super-triangle that contains all points
            const minX = Math.min(...points.map(p => p[0])) - 1000;
            const minY = Math.min(...points.map(p => p[1])) - 1000;
            const maxX = Math.max(...points.map(p => p[0])) + 1000;
            const maxY = Math.max(...points.map(p => p[1])) + 1000;

            const superTriangle = [
                [minX, minY],
                [maxX, minY],
                [(minX + maxX) / 2, maxY]
            ];

            let triangles = [[0, 1, 2]];
            const vertices = [...superTriangle, ...points];

            // Add points one at a time
            for (let i = 0; i < points.length; i++) {
                const pointIdx = i + 3; // Offset by super-triangle vertices
                const point = vertices[pointIdx];
                const badTriangles = [];

                // Find triangles whose circumcircle contains the point
                for (let j = 0; j < triangles.length; j++) {
                    const tri = triangles[j];
                    const [ax, ay] = vertices[tri[0]];
                    const [bx, by] = vertices[tri[1]];
                    const [cx, cy] = vertices[tri[2]];

                    if (inCircumcircle(point[0], point[1], ax, ay, bx, by, cx, cy)) {
                        badTriangles.push(j);
                    }
                }

                // Find boundary edges
                const polygon = [];
                for (const triIdx of badTriangles) {
                    const tri = triangles[triIdx];
                    const edges = [[tri[0], tri[1]], [tri[1], tri[2]], [tri[2], tri[0]]];

                    for (const edge of edges) {
                        let shared = false;
                        for (const otherTriIdx of badTriangles) {
                            if (otherTriIdx === triIdx) continue;
                            const otherTri = triangles[otherTriIdx];
                            if (hasEdge(otherTri, edge[0], edge[1])) {
                                shared = true;
                                break;
                            }
                        }
                        if (!shared) {
                            polygon.push(edge);
                        }
                    }
                }

                // Remove bad triangles
                for (let j = badTriangles.length - 1; j >= 0; j--) {
                    triangles.splice(badTriangles[j], 1);
                }

                // Add new triangles
                for (const edge of polygon) {
                    triangles.push([edge[0], edge[1], pointIdx]);
                }
            }

            // Remove triangles that share vertices with super-triangle
            triangles = triangles.filter(tri =>
                tri[0] >= 3 && tri[1] >= 3 && tri[2] >= 3
            );

            // Adjust indices (remove super-triangle offset)
            triangles = triangles.map(tri =>
                tri.map(idx => idx - 3)
            );

            return { triangles, vertices: points };
        }

        function inCircumcircle(px, py, ax, ay, bx, by, cx, cy) {
            const ax_ = ax - px;
            const ay_ = ay - py;
            const bx_ = bx - px;
            const by_ = by - py;
            const cx_ = cx - px;
            const cy_ = cy - py;

            return (
                (ax_ * ax_ + ay_ * ay_) * (bx_ * cy_ - cx_ * by_) -
                (bx_ * bx_ + by_ * by_) * (ax_ * cy_ - cx_ * ay_) +
                (cx_ * cx_ + cy_ * cy_) * (ax_ * by_ - bx_ * ay_)
            ) > 0;
        }

        function hasEdge(tri, a, b) {
            return (tri.includes(a) && tri.includes(b));
        }

        // Calculate triangle centroid (node position)
        function getCentroid(p1, p2, p3) {
            return [
                (p1[0] + p2[0] + p3[0]) / 3,
                (p1[1] + p2[1] + p3[1]) / 3
            ];
        }

        // Calculate angle in degrees at vertex B in triangle ABC
        function getAngle(a, b, c) {
            const ba = [a[0] - b[0], a[1] - b[1]];
            const bc = [c[0] - b[0], c[1] - b[1]];
            const dotProduct = ba[0] * bc[0] + ba[1] * bc[1];
            const magBA = Math.sqrt(ba[0] * ba[0] + ba[1] * ba[1]);
            const magBC = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]);
            const cosAngle = dotProduct / (magBA * magBC);
            return Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI;
        }

        // Check if triangle has all angles above threshold
        function isTriangleValid(p1, p2, p3, minAngleDeg) {
            const angle1 = getAngle(p2, p1, p3);
            const angle2 = getAngle(p1, p2, p3);
            const angle3 = getAngle(p1, p3, p2);
            return angle1 >= minAngleDeg && angle2 >= minAngleDeg && angle3 >= minAngleDeg;
        }

        // Find neighboring triangles (share an edge) - for nodes
        function findNeighbors(triangles) {
            const neighbors = triangles.map(() => []);

            for (let i = 0; i < triangles.length; i++) {
                const tri1 = triangles[i];
                const edges1 = [
                    [tri1[0], tri1[1]],
                    [tri1[1], tri1[2]],
                    [tri1[2], tri1[0]]
                ];

                for (let j = i + 1; j < triangles.length; j++) {
                    const tri2 = triangles[j];

                    // Check if triangles share an edge
                    for (const edge of edges1) {
                        if (hasEdge(tri2, edge[0], edge[1])) {
                            neighbors[i].push(j);
                            neighbors[j].push(i);
                            break;
                        }
                    }
                }
            }

            return neighbors;
        }

        // Build Voronoi diagram and tile structure
        function buildVoronoi(points, triangles) {
            const minAngleDeg = parseFloat(document.getElementById('minAngle').value);

            // Check triangle validity and calculate centroids (blue nodes)
            validTriangles = new Set();
            voronoiVertices = [];
            for (let i = 0; i < triangles.length; i++) {
                const tri = triangles[i];
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];

                if (isTriangleValid(p1, p2, p3, minAngleDeg)) {
                    validTriangles.add(i);
                    voronoiVertices.push(getCentroid(p1, p2, p3));
                } else {
                    voronoiVertices.push(null); // Placeholder for invalid triangles
                }
            }

            // Find triangle neighbors (share an edge)
            const triangleNeighbors = findNeighbors(triangles);

            // Build Voronoi edges (green lines) - connect centroids of adjacent valid triangles
            voronoiEdges = [];
            for (let i = 0; i < triangles.length; i++) {
                if (!validTriangles.has(i)) continue;
                for (const j of triangleNeighbors[i]) {
                    if (j > i && validTriangles.has(j)) { // Both triangles must be valid
                        voronoiEdges.push([i, j]);
                    }
                }
            }

            // Build tiles: for each point, find all triangles containing it
            tiles = [];
            tileNeighbors = [];
            validTiles = new Set();
            edgeTiles = new Set();
            ineligibleTiles = new Set();

            for (let i = 0; i < points.length; i++) {
                // Find all valid triangles containing point i
                const trianglesWithPoint = [];
                for (let t = 0; t < triangles.length; t++) {
                    if (triangles[t].includes(i) && validTriangles.has(t)) {
                        trianglesWithPoint.push(t);
                    }
                }

                tiles.push(trianglesWithPoint);

                // Find Delaunay neighbors: points connected by Delaunay edges from valid triangles
                const delaunayNeighbors = new Set();
                for (const t of trianglesWithPoint) {
                    for (const v of triangles[t]) {
                        if (v !== i) {
                            delaunayNeighbors.add(v);
                        }
                    }
                }

                // Find Voronoi neighbors: points that share a Voronoi edge (green line)
                // These are neighbors where the connecting Delaunay edge crosses a Voronoi edge
                const voronoiNeighbors = new Set();
                for (const neighbor of delaunayNeighbors) {
                    // Check if this neighbor shares a Voronoi edge
                    // They share a Voronoi edge if there are two valid triangles that both contain i and neighbor
                    let sharedValidTriangles = 0;
                    for (const t of trianglesWithPoint) {
                        if (triangles[t].includes(neighbor)) {
                            sharedValidTriangles++;
                        }
                    }
                    if (sharedValidTriangles >= 2) {
                        voronoiNeighbors.add(neighbor);
                    }
                }

                tileNeighbors.push(Array.from(voronoiNeighbors));

                // Validate tile: all tiles are valid if they have at least 3 vertices
                if (trianglesWithPoint.length >= 3) {
                    validTiles.add(i);

                    // Edge tile detection: if N Delaunay edges but fewer than N Voronoi neighbors
                    const numDelaunayEdges = delaunayNeighbors.size;
                    const numVoronoiNeighbors = voronoiNeighbors.size;

                    if (numVoronoiNeighbors < numDelaunayEdges) {
                        edgeTiles.add(i);
                    }

                    // Ineligible tiles: N valid edges but fewer than N valid neighbors
                    if (numVoronoiNeighbors < numDelaunayEdges) {
                        ineligibleTiles.add(i);
                    }
                }
            }

            // Expand ineligible tiles: any tile next to an ineligible tile is also ineligible
            const initialIneligible = new Set(ineligibleTiles);
            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i)) continue;
                if (initialIneligible.has(i)) continue;

                // Check if any neighbor is ineligible
                for (const neighbor of tileNeighbors[i]) {
                    if (initialIneligible.has(neighbor)) {
                        ineligibleTiles.add(i);
                        break;
                    }
                }
            }
        }

        // Find center tile (closest to canvas center)
        function findCenterTile() {
            const cx = width / 2;
            const cy = height / 2;
            let minDist = Infinity;
            let centerIdx = 0;

            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i) || ineligibleTiles.has(i)) continue;
                const dx = points[i][0] - cx;
                const dy = points[i][1] - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    centerIdx = i;
                }
            }

            return centerIdx;
        }

        // Calculate distance between two points
        function distance(p1, p2) {
            const dx = p1[0] - p2[0];
            const dy = p1[1] - p2[1];
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculate centroid of a polygon (for Lloyd's algorithm)
        function getPolygonCentroid(vertices) {
            if (vertices.length < 3) return null;

            let cx = 0, cy = 0;
            let area = 0;

            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                const cross = vertices[i][0] * vertices[j][1] - vertices[j][0] * vertices[i][1];
                area += cross;
                cx += (vertices[i][0] + vertices[j][0]) * cross;
                cy += (vertices[i][1] + vertices[j][1]) * cross;
            }

            area *= 0.5;
            if (Math.abs(area) < 1e-10) return null;

            cx /= (6 * area);
            cy /= (6 * area);

            return [cx, cy];
        }

        // Check if there are any 4-sided tiles among eligible tiles
        function hasFourSidedTiles() {
            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i)) continue;
                if (ineligibleTiles.has(i)) continue;

                const numNeighbors = tileNeighbors[i].length;
                if (numNeighbors === 4) {
                    return true;
                }
            }
            return false;
        }

        // Apply Lloyd's relaxation: move each point to centroid of its Voronoi cell
        function applyLloydsRelaxation() {
            const newPoints = [];

            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i) || tiles[i].length < 3) {
                    // Keep invalid tiles in place
                    newPoints.push([...points[i]]);
                    continue;
                }

                // Get the tile's vertices (centroids of triangles containing this point)
                const tileVertices = tiles[i].map(t => voronoiVertices[t]).filter(v => v !== null);

                if (tileVertices.length < 3) {
                    newPoints.push([...points[i]]);
                    continue;
                }

                // Order vertices around the center point
                const center = points[i];
                tileVertices.sort((a, b) => {
                    const angleA = Math.atan2(a[1] - center[1], a[0] - center[0]);
                    const angleB = Math.atan2(b[1] - center[1], b[0] - center[0]);
                    return angleA - angleB;
                });

                // Calculate polygon centroid
                const centroid = getPolygonCentroid(tileVertices);

                if (centroid) {
                    // Keep point within bounds
                    const x = Math.max(bounds.x, Math.min(bounds.x + bounds.width, centroid[0]));
                    const y = Math.max(bounds.y, Math.min(bounds.y + bounds.height, centroid[1]));
                    newPoints.push([x, y]);
                } else {
                    newPoints.push([...points[i]]);
                }
            }

            return newPoints;
        }

        // Main generation and drawing function
        function generatePoints(type) {
            currentPointType = type;
            ctx.clearRect(0, 0, width, height);

            // Generate points
            if (type === 'poisson') {
                points = poissonDiscSampling(500);
            } else {
                points = generateHexGrid(500);
            }

            if (points.length < 3) {
                alert('Not enough points generated!');
                return;
            }

            // Compute Delaunay triangulation
            let result = delaunay(points);
            triangles = result.triangles;

            if (triangles.length === 0) {
                alert('Triangulation failed!');
                return;
            }

            // Build Voronoi diagram and tile structure
            buildVoronoi(points, triangles);

            // Apply Lloyd's relaxation for Poisson mode if enabled
            const useLloyd = document.getElementById('lloydRelaxation').checked;
            if (type === 'poisson' && useLloyd) {
                const maxIterations = 50;
                let iteration = 0;

                while (hasFourSidedTiles() && iteration < maxIterations) {
                    // Apply relaxation
                    points = applyLloydsRelaxation();

                    // Recompute triangulation
                    result = delaunay(points);
                    triangles = result.triangles;

                    if (triangles.length === 0) break;

                    // Rebuild Voronoi
                    buildVoronoi(points, triangles);

                    iteration++;
                }

                console.log(`Lloyd's relaxation: ${iteration} iterations`);
            }

            // Draw black lines (Delaunay edges) - only for valid triangles
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < triangles.length; i++) {
                if (!validTriangles.has(i)) continue;
                const tri = triangles[i];
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.lineTo(p3[0], p3[1]);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw green lines (Voronoi edges / tile boundaries)
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1.5;
            for (const edge of voronoiEdges) {
                const v1 = voronoiVertices[edge[0]];
                const v2 = voronoiVertices[edge[1]];
                if (v1 && v2) { // Only draw if both vertices are valid
                    ctx.beginPath();
                    ctx.moveTo(v1[0], v1[1]);
                    ctx.lineTo(v2[0], v2[1]);
                    ctx.stroke();
                }
            }

            // Draw blue circles (Voronoi vertices / tile corners)
            ctx.fillStyle = 'blue';
            for (const vertex of voronoiVertices) {
                if (vertex) { // Only draw valid vertices
                    ctx.beginPath();
                    ctx.arc(vertex[0], vertex[1], 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Draw red circles (tile centers)
            // Valid tiles = solid red, invalid/edge tiles = red with yellow outline
            for (let i = 0; i < points.length; i++) {
                const point = points[i];

                if (!validTiles.has(i)) {
                    // Invalid tile - yellow circle
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (edgeTiles.has(i)) {
                    // Edge tile - orange circle
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Draw the center point
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Generate map with land and water tiles
        function generateMap(mode) {
            if (triangles.length === 0) {
                alert('Please generate points first!');
                return;
            }

            const centerTile = findCenterTile();
            const landTiles = new Set();
            const numTiles = parseInt(document.getElementById('numTiles').value);

            if (mode === 'hex-standard') {
                // Center + 6 neighbors + 12 neighbors
                landTiles.add(centerTile);

                // Add first ring (6 neighbors)
                const ring1 = tileNeighbors[centerTile].filter(t => validTiles.has(t) && !ineligibleTiles.has(t));
                ring1.forEach(t => landTiles.add(t));

                // Add second ring (12 neighbors)
                const ring2 = new Set();
                ring1.forEach(t => {
                    tileNeighbors[t].forEach(n => {
                        if (!landTiles.has(n) && validTiles.has(n) && !ineligibleTiles.has(n)) {
                            ring2.add(n);
                        }
                    });
                });
                ring2.forEach(t => landTiles.add(t));

            } else if (mode === 'hex-expanded' || mode === 'delaunay-expanded') {
                // Random propagation from center (excluding ineligible tiles)
                landTiles.add(centerTile);
                const frontier = [centerTile];

                while (landTiles.size < numTiles && frontier.length > 0) {
                    const randomIdx = Math.floor(Math.random() * frontier.length);
                    const current = frontier[randomIdx];
                    frontier.splice(randomIdx, 1);

                    // Get valid neighbors (non-ineligible tiles only)
                    let neighbors = tileNeighbors[current].filter(n =>
                        validTiles.has(n) && !ineligibleTiles.has(n)
                    );

                    // Shuffle and add neighbors
                    const shuffled = neighbors.sort(() => Math.random() - 0.5);
                    for (const neighbor of shuffled) {
                        if (!landTiles.has(neighbor) && landTiles.size < numTiles) {
                            landTiles.add(neighbor);
                            frontier.push(neighbor);
                        }
                    }
                }
            }

            // Run erosion/accretion rounds (Y rounds)
            const erosionRounds = parseInt(document.getElementById('erosionRounds').value);
            const rootTile = centerTile;

            for (let round = 0; round < erosionRounds; round++) {
                // Find shore tiles (land with >= 1 non-land neighbor)
                const shoreTiles = [];
                landTiles.forEach(tile => {
                    const hasNonLandNeighbor = tileNeighbors[tile].some(n => !landTiles.has(n));
                    if (hasNonLandNeighbor) {
                        shoreTiles.push(tile);
                    }
                });

                if (shoreTiles.length === 0) break;

                // Find closest shore tile to root
                let closestShore = shoreTiles[0];
                let minDist = distance(points[rootTile], points[closestShore]);
                for (const tile of shoreTiles) {
                    const dist = distance(points[rootTile], points[tile]);
                    if (dist < minDist) {
                        minDist = dist;
                        closestShore = tile;
                    }
                }

                // Remove closest shore tile from land
                landTiles.delete(closestShore);

                // Recalculate shore tiles
                const newShoreTiles = [];
                landTiles.forEach(tile => {
                    const hasNonLandNeighbor = tileNeighbors[tile].some(n => !landTiles.has(n));
                    if (hasNonLandNeighbor) {
                        newShoreTiles.push(tile);
                    }
                });

                if (newShoreTiles.length === 0) {
                    landTiles.add(closestShore); // Restore if no shore remains
                    break;
                }

                // Find furthest shore tile from root
                let furthestShore = newShoreTiles[0];
                let maxDist = distance(points[rootTile], points[furthestShore]);
                for (const tile of newShoreTiles) {
                    const dist = distance(points[rootTile], points[tile]);
                    if (dist > maxDist) {
                        maxDist = dist;
                        furthestShore = tile;
                    }
                }

                // Find non-land neighbors of furthest shore
                const nonLandNeighbors = tileNeighbors[furthestShore].filter(n =>
                    !landTiles.has(n) && validTiles.has(n) && !ineligibleTiles.has(n)
                );

                // Add one non-land neighbor as land (pick randomly if multiple)
                if (nonLandNeighbors.length > 0) {
                    const randomNeighbor = nonLandNeighbors[Math.floor(Math.random() * nonLandNeighbors.length)];
                    landTiles.add(randomNeighbor);
                }
            }

            // Determine water tiles (neighbors of land tiles)
            const waterTiles = new Set();
            landTiles.forEach(tile => {
                tileNeighbors[tile].forEach(neighbor => {
                    if (!landTiles.has(neighbor) && validTiles.has(neighbor)) {
                        waterTiles.add(neighbor);
                    }
                });
            });

            // Post-processing: fix isolated tiles with non-adjacent water neighbors
            const tilesToFix = [];
            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i)) continue;
                if (waterTiles.has(i)) continue; // Skip existing water tiles

                const neighbors = tileNeighbors[i];
                if (neighbors.length < 2) continue;

                // Find water neighbors
                const waterNeighborIndices = [];
                for (let j = 0; j < neighbors.length; j++) {
                    if (waterTiles.has(neighbors[j])) {
                        waterNeighborIndices.push(j);
                    }
                }

                if (waterNeighborIndices.length < 2) continue;

                // Check if any two water neighbors are non-adjacent
                let hasNonAdjacentWater = false;
                for (let a = 0; a < waterNeighborIndices.length; a++) {
                    for (let b = a + 1; b < waterNeighborIndices.length; b++) {
                        const idxA = waterNeighborIndices[a];
                        const idxB = waterNeighborIndices[b];
                        const diff = Math.abs(idxA - idxB);

                        // Non-adjacent if not consecutive in circular order
                        if (diff !== 1 && diff !== neighbors.length - 1) {
                            hasNonAdjacentWater = true;
                            break;
                        }
                    }
                    if (hasNonAdjacentWater) break;
                }

                if (hasNonAdjacentWater) {
                    tilesToFix.push(i);
                }
            }

            // Apply fixes
            for (const tile of tilesToFix) {
                const neighbors = tileNeighbors[tile];
                const allWater = neighbors.every(n => waterTiles.has(n));
                const hasLand = neighbors.some(n => landTiles.has(n));

                if (allWater) {
                    waterTiles.add(tile);
                    landTiles.delete(tile);
                } else if (hasLand) {
                    landTiles.add(tile);
                }
                // Otherwise leave as null (no change)
            }

            // Redraw everything with colors
            ctx.clearRect(0, 0, width, height);

            // Draw tiles (Voronoi cells) with fill colors
            for (let i = 0; i < points.length; i++) {
                if (!validTiles.has(i) || tiles[i].length < 3) continue;

                // Get the tile's vertices (centroids of triangles containing this point)
                const tileVertices = tiles[i].map(t => voronoiVertices[t]).filter(v => v !== null);

                if (tileVertices.length < 3) continue;

                // Order vertices around the center point
                const center = points[i];
                tileVertices.sort((a, b) => {
                    const angleA = Math.atan2(a[1] - center[1], a[0] - center[0]);
                    const angleB = Math.atan2(b[1] - center[1], b[0] - center[0]);
                    return angleA - angleB;
                });

                // Determine color
                if (landTiles.has(i)) {
                    ctx.fillStyle = 'rgba(34, 139, 34, 0.5)'; // Green land
                } else if (waterTiles.has(i)) {
                    ctx.fillStyle = 'rgba(30, 144, 255, 0.5)'; // Blue water
                } else {
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; // Gray void
                }

                // Draw the tile polygon
                ctx.beginPath();
                ctx.moveTo(tileVertices[0][0], tileVertices[0][1]);
                for (let j = 1; j < tileVertices.length; j++) {
                    ctx.lineTo(tileVertices[j][0], tileVertices[j][1]);
                }
                ctx.closePath();
                ctx.fill();
            }

            // Draw black lines (Delaunay edges) - only for valid triangles
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < triangles.length; i++) {
                if (!validTriangles.has(i)) continue;
                const tri = triangles[i];
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.lineTo(p3[0], p3[1]);
                ctx.closePath();
                ctx.stroke();
            }

            // Draw green lines (Voronoi edges / tile boundaries)
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1.5;
            for (const edge of voronoiEdges) {
                const v1 = voronoiVertices[edge[0]];
                const v2 = voronoiVertices[edge[1]];
                if (v1 && v2) { // Only draw if both vertices are valid
                    ctx.beginPath();
                    ctx.moveTo(v1[0], v1[1]);
                    ctx.lineTo(v2[0], v2[1]);
                    ctx.stroke();
                }
            }

            // Draw blue circles (Voronoi vertices / tile corners)
            ctx.fillStyle = 'blue';
            for (const vertex of voronoiVertices) {
                if (vertex) { // Only draw valid vertices
                    ctx.beginPath();
                    ctx.arc(vertex[0], vertex[1], 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Draw red circles (tile centers)
            for (let i = 0; i < points.length; i++) {
                const point = points[i];

                if (!validTiles.has(i)) {
                    // Invalid tile - yellow circle
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (edgeTiles.has(i)) {
                    // Edge tile - orange circle
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Draw the center point
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Initialize with hex grid
        generatePoints('hex');
    </script>
</body>
</html>
