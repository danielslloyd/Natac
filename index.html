<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Natac - Catan-like Polygon Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .setup-screen {
      padding: 40px;
    }

    .setup-section {
      margin-bottom: 30px;
    }

    .setup-section h2 {
      margin-bottom: 15px;
      color: #333;
    }

    .map-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .map-option {
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .map-option:hover {
      border-color: #667eea;
      background: #f8f9ff;
      transform: translateY(-2px);
    }

    .map-option.selected {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .map-option h3 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .map-option p {
      color: #666;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .player-setup {
      margin-top: 20px;
    }

    .player-inputs {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .player-input {
      display: flex;
      flex-direction: column;
    }

    .player-input label {
      margin-bottom: 5px;
      font-weight: 500;
      color: #555;
    }

    .player-input input {
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
    }

    .player-input input:focus {
      outline: none;
      border-color: #667eea;
    }

    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.1rem;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
      margin-top: 20px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .game-screen {
      display: none;
      padding: 20px;
    }

    .game-layout {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
    }

    .sidebar {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      height: fit-content;
    }

    .player-info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border-left: 4px solid #667eea;
    }

    .player-info.current {
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .player-info h3 {
      margin-bottom: 10px;
      color: #333;
    }

    .resource-list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      font-size: 0.9rem;
      color: #666;
    }

    .canvas-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      position: relative;
      overflow: auto;
    }

    #gameCanvas {
      display: block;
      margin: 0 auto;
      cursor: crosshair;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .controls button {
      padding: 10px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
    }

    .controls button:hover {
      background: #5568d3;
    }

    .controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .info-panel {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .resource-display {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .resource-item {
      padding: 8px 15px;
      background: white;
      border-radius: 6px;
      font-size: 0.9rem;
      border: 1px solid #e0e0e0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé≤ Natac</h1>
      <p>A Catan-like game on arbitrary polygon maps</p>
    </div>

    <div id="setupScreen" class="setup-screen">
      <div class="setup-section">
        <h2>Choose Your Map</h2>
        <div class="map-options">
          <div class="map-option selected" data-map-type="standard">
            <h3>Standard Catan Map</h3>
            <p>Classic 19-hex Catan board with standard resource distribution</p>
          </div>
          <div class="map-option" data-map-type="expanded-hex">
            <h3>Expanded Hex Grid</h3>
            <p>Larger hexagonal map with more tiles for extended gameplay</p>
          </div>
          <div class="map-option" data-map-type="expanded-delaunay">
            <h3>Delaunay Polygon Map</h3>
            <p>Organic-looking irregular polygons using Delaunay-centroid algorithm</p>
          </div>
        </div>
      </div>

      <div class="setup-section">
        <h2>Players</h2>
        <div class="player-setup">
          <div class="player-inputs">
            <div class="player-input">
              <label>Player 1</label>
              <input type="text" id="player1" value="Alice" />
            </div>
            <div class="player-input">
              <label>Player 2</label>
              <input type="text" id="player2" value="Bob" />
            </div>
            <div class="player-input">
              <label>Player 3</label>
              <input type="text" id="player3" value="Charlie" />
            </div>
            <div class="player-input">
              <label>Player 4 (Optional)</label>
              <input type="text" id="player4" placeholder="Optional" />
            </div>
          </div>
        </div>
      </div>

      <button class="btn" id="startGameBtn">Start Game</button>
    </div>

    <div id="gameScreen" class="game-screen">
      <div class="game-layout">
        <div class="sidebar">
          <h2 style="margin-bottom: 15px;">Players</h2>
          <div id="playerList"></div>

          <div id="currentPlayerInfo" class="info-panel" style="margin-top: 20px;">
            <h3 style="margin-bottom: 10px;">Current Turn</h3>
            <p id="currentPlayerText">-</p>
          </div>

          <div class="controls">
            <button id="rollDiceBtn">Roll Dice</button>
            <button id="endTurnBtn">End Turn</button>
          </div>

          <div id="diceResult" style="margin-top: 15px; font-size: 1.2rem; font-weight: bold;"></div>
        </div>

        <div class="canvas-container">
          <div id="mapInfo" class="info-panel">
            <strong>Map Type:</strong> <span id="mapTypeDisplay">-</span><br>
            <strong>Tiles:</strong> <span id="tileCount">-</span> |
            <strong>Nodes:</strong> <span id="nodeCount">-</span> |
            <strong>Edges:</strong> <span id="edgeCount">-</span>
          </div>
          <canvas id="gameCanvas" width="900" height="700"></canvas>
          <div id="clickInfo" style="margin-top: 10px; font-size: 0.9rem; color: #666;">
            Click on nodes to place settlements, click on edges to place roads
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Include map generation module -->
  <script src="./src/mapgen.js"></script>

  <script type="module">
    // This will be populated with the compiled game logic
    import * as Game from './dist/index.js';

    let gameState = null;
    let selectedMapType = 'standard';
    let canvas, ctx;

    // View state for zoom and pan
    let viewState = {
      zoom: 1.0,
      minZoom: 1.0,
      maxZoom: 3.0,
      panX: 0,
      panY: 0,
      mapBounds: { minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }
    };

    // Setup screen event listeners
    document.querySelectorAll('.map-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.map-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedMapType = option.dataset.mapType;
      });
    });

    document.getElementById('startGameBtn').addEventListener('click', startGame);

    function startGame() {
      const playerNames = [
        document.getElementById('player1').value,
        document.getElementById('player2').value,
        document.getElementById('player3').value,
        document.getElementById('player4').value
      ].filter(name => name.trim() !== '');

      if (playerNames.length < 2) {
        alert('Please enter at least 2 player names');
        return;
      }

      const options = {
        mapType: selectedMapType,
        enhancedKnights: true,
        seed: Date.now(),
        expandedMapSize: 30,
        delaunayTileCount: 30
      };

      try {
        gameState = Game.createGame(playerNames, options);
        console.log('Game created:', gameState);

        document.getElementById('setupScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';

        initializeCanvas();
        updateUI();
        renderMap();
      } catch (error) {
        alert('Error creating game: ' + error.message);
        console.error(error);
      }
    }

    function initializeCanvas() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      // Calculate map bounds
      calculateMapBounds();

      // Add event listeners
      canvas.addEventListener('click', handleCanvasClick);
      canvas.addEventListener('wheel', handleZoom, { passive: false });
      canvas.addEventListener('mousedown', handlePanStart);
      canvas.addEventListener('mousemove', handlePanMove);
      canvas.addEventListener('mouseup', handlePanEnd);

      // Update map info
      document.getElementById('mapTypeDisplay').textContent = selectedMapType;
      document.getElementById('tileCount').textContent = gameState.tiles.length;
      document.getElementById('nodeCount').textContent = gameState.nodes.length;
      document.getElementById('edgeCount').textContent = gameState.edges.length;
    }

    function calculateMapBounds() {
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;

      // Check all tile polygon points
      gameState.tiles.forEach(tile => {
        if (tile.polygonPoints) {
          tile.polygonPoints.forEach(([x, y]) => {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          });
        }
      });

      // Check all node locations
      gameState.nodes.forEach(node => {
        if (node.location) {
          minX = Math.min(minX, node.location[0]);
          minY = Math.min(minY, node.location[1]);
          maxX = Math.max(maxX, node.location[0]);
          maxY = Math.max(maxY, node.location[1]);
        }
      });

      viewState.mapBounds = {
        minX, minY, maxX, maxY,
        width: maxX - minX,
        height: maxY - minY
      };

      // Calculate initial zoom to fit map in canvas with padding
      const padding = 40;
      const scaleX = (canvas.width - padding * 2) / viewState.mapBounds.width;
      const scaleY = (canvas.height - padding * 2) / viewState.mapBounds.height;
      viewState.minZoom = Math.min(scaleX, scaleY);
      viewState.zoom = viewState.minZoom;

      // Center the view
      resetView();
    }

    function resetView() {
      viewState.zoom = viewState.minZoom;
      viewState.panX = 0;
      viewState.panY = 0;
    }

    // Pan handling
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let lastPanX = 0;
    let lastPanY = 0;

    function handlePanStart(event) {
      if (viewState.zoom > viewState.minZoom) {
        isPanning = true;
        panStartX = event.clientX;
        panStartY = event.clientY;
        lastPanX = viewState.panX;
        lastPanY = viewState.panY;
        canvas.style.cursor = 'grabbing';
      }
    }

    function handlePanMove(event) {
      if (isPanning) {
        const dx = event.clientX - panStartX;
        const dy = event.clientY - panStartY;
        viewState.panX = lastPanX + dx;
        viewState.panY = lastPanY + dy;
        renderMap();
      } else if (viewState.zoom > viewState.minZoom) {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'crosshair';
      }
    }

    function handlePanEnd() {
      isPanning = false;
      if (viewState.zoom > viewState.minZoom) {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'crosshair';
      }
    }

    function handleZoom(event) {
      event.preventDefault();

      const delta = -event.deltaY * 0.001;
      const oldZoom = viewState.zoom;
      viewState.zoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom * (1 + delta)));

      // If zoomed out to minimum, reset pan
      if (viewState.zoom === viewState.minZoom) {
        viewState.panX = 0;
        viewState.panY = 0;
      } else {
        // Zoom towards mouse position
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left - canvas.width / 2;
        const mouseY = event.clientY - rect.top - canvas.height / 2;

        const zoomRatio = viewState.zoom / oldZoom - 1;
        viewState.panX -= mouseX * zoomRatio;
        viewState.panY -= mouseY * zoomRatio;
      }

      renderMap();
    }

    function updateUI() {
      const playerList = document.getElementById('playerList');
      playerList.innerHTML = '';

      gameState.players.forEach((player, idx) => {
        const isCurrent = idx === gameState.currentPlayerIdx;
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-info' + (isCurrent ? ' current' : '');

        const resources = Object.entries(player.resources)
          .filter(([res]) => res !== 'desert')
          .map(([res, count]) => `${res}: ${count}`)
          .join(', ');

        playerDiv.innerHTML = `
          <h3>${player.name} ${isCurrent ? '‚≠ê' : ''}</h3>
          <div style="margin-bottom: 10px;">
            <strong>VP:</strong> ${player.victoryPoints} |
            <strong>Settlements:</strong> ${player.settlements.length} |
            <strong>Cities:</strong> ${player.cities.length}
          </div>
          <div class="resource-display">
            ${Object.entries(player.resources)
              .filter(([res]) => res !== 'desert')
              .map(([res, count]) => `<div class="resource-item">${res}: ${count}</div>`)
              .join('')}
          </div>
        `;

        playerList.appendChild(playerDiv);
      });

      const currentPlayer = Game.getCurrentPlayer(gameState);
      document.getElementById('currentPlayerText').textContent =
        `${currentPlayer.name}'s turn (${gameState.phase === 'setup' ? 'Setup' : 'Main'} phase)`;

      // Setup event listeners
      document.getElementById('rollDiceBtn').onclick = handleRollDice;
      document.getElementById('endTurnBtn').onclick = handleEndTurn;
    }

    function renderMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Calculate transform to center and scale the map
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const mapCenterX = (viewState.mapBounds.minX + viewState.mapBounds.maxX) / 2;
      const mapCenterY = (viewState.mapBounds.minY + viewState.mapBounds.maxY) / 2;

      ctx.save();
      ctx.translate(centerX + viewState.panX, centerY + viewState.panY);
      ctx.scale(viewState.zoom, viewState.zoom);
      ctx.translate(-mapCenterX, -mapCenterY);

      // Draw tiles
      gameState.tiles.forEach(tile => {
        if (!tile.polygonPoints || tile.polygonPoints.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(tile.polygonPoints[0][0], tile.polygonPoints[0][1]);
        for (let i = 1; i < tile.polygonPoints.length; i++) {
          ctx.lineTo(tile.polygonPoints[i][0], tile.polygonPoints[i][1]);
        }
        ctx.closePath();

        // Fill based on resource
        const colors = {
          wood: '#228B22',
          brick: '#A0522D',
          sheep: '#90EE90',
          wheat: '#FFD700',
          ore: '#708090',
          desert: '#DEB887'
        };
        ctx.fillStyle = colors[tile.resource] || '#ccc';
        ctx.fill();

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw dice number
        if (tile.diceNumber) {
          const center = tile.polygonPoints.reduce(
            (acc, p) => [acc[0] + p[0], acc[1] + p[1]],
            [0, 0]
          );
          center[0] /= tile.polygonPoints.length;
          center[1] /= tile.polygonPoints.length;

          ctx.fillStyle = tile.robberPresent ? 'red' : 'white';
          ctx.beginPath();
          ctx.arc(center[0], center[1], 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.fillStyle = '#000';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.diceNumber.toString(), center[0], center[1]);
        }

        // Draw robber indicator
        if (tile.robberPresent) {
          const center = tile.polygonPoints.reduce(
            (acc, p) => [acc[0] + p[0], acc[1] + p[1]],
            [0, 0]
          );
          center[0] /= tile.polygonPoints.length;
          center[1] /= tile.polygonPoints.length;

          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.beginPath();
          ctx.arc(center[0], center[1] + 25, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Draw edges (roads)
      gameState.edges.forEach(edge => {
        const nodeA = gameState.nodes.find(n => n.id === edge.nodeA);
        const nodeB = gameState.nodes.find(n => n.id === edge.nodeB);

        if (!nodeA?.location || !nodeB?.location) return;

        ctx.beginPath();
        ctx.moveTo(nodeA.location[0], nodeA.location[1]);
        ctx.lineTo(nodeB.location[0], nodeB.location[1]);

        if (edge.roadOwner) {
          const owner = gameState.players.find(p => p.id === edge.roadOwner);
          ctx.strokeStyle = owner?.color || '#000';
          ctx.lineWidth = 5;
        } else {
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.lineWidth = 1;
        }

        ctx.stroke();
      });

      // Draw nodes (settlements/cities)
      gameState.nodes.forEach(node => {
        if (!node.location) return;

        ctx.beginPath();
        ctx.arc(node.location[0], node.location[1], 6, 0, Math.PI * 2);

        if (node.occupant) {
          const owner = gameState.players.find(p => p.id === node.occupant.playerId);
          ctx.fillStyle = owner?.color || '#000';
          if (node.occupant.type === 'city') {
            ctx.arc(node.location[0], node.location[1], 10, 0, Math.PI * 2);
          }
        } else {
          ctx.fillStyle = 'white';
        }

        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      ctx.restore();

      // Draw mini-map when zoomed in
      if (viewState.zoom > viewState.minZoom) {
        drawMiniMap();
      }

      // Draw zoom controls hint
      ctx.save();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillRect(10, 10, 200, 60);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(10, 10, 200, 60);
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.fillText('Scroll: Zoom', 20, 30);
      ctx.fillText('Drag: Pan (when zoomed)', 20, 50);
      ctx.fillText(`Zoom: ${(viewState.zoom / viewState.minZoom * 100).toFixed(0)}%`, 20, 65);
      ctx.restore();
    }

    function drawMiniMap() {
      const miniSize = 150;
      const miniX = canvas.width - miniSize - 20;
      const miniY = 20;
      const miniPadding = 5;

      ctx.save();

      // Draw mini-map background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillRect(miniX, miniY, miniSize, miniSize);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.strokeRect(miniX, miniY, miniSize, miniSize);

      // Calculate mini-map scale
      const miniScale = (miniSize - miniPadding * 2) / Math.max(viewState.mapBounds.width, viewState.mapBounds.height);
      const mapCenterX = (viewState.mapBounds.minX + viewState.mapBounds.maxX) / 2;
      const mapCenterY = (viewState.mapBounds.minY + viewState.mapBounds.maxY) / 2;

      ctx.translate(miniX + miniSize / 2, miniY + miniSize / 2);
      ctx.scale(miniScale, miniScale);
      ctx.translate(-mapCenterX, -mapCenterY);

      // Draw simplified map
      gameState.tiles.forEach(tile => {
        if (!tile.polygonPoints || tile.polygonPoints.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(tile.polygonPoints[0][0], tile.polygonPoints[0][1]);
        for (let i = 1; i < tile.polygonPoints.length; i++) {
          ctx.lineTo(tile.polygonPoints[i][0], tile.polygonPoints[i][1]);
        }
        ctx.closePath();

        const colors = {
          wood: '#228B22',
          brick: '#A0522D',
          sheep: '#90EE90',
          wheat: '#FFD700',
          ore: '#708090',
          desert: '#DEB887'
        };
        ctx.fillStyle = colors[tile.resource] || '#ccc';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5 / miniScale;
        ctx.stroke();
      });

      // Draw viewport indicator
      const viewportWidth = canvas.width / viewState.zoom;
      const viewportHeight = canvas.height / viewState.zoom;
      const viewCenterX = mapCenterX - viewState.panX / viewState.zoom;
      const viewCenterY = mapCenterY - viewState.panY / viewState.zoom;

      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2 / miniScale;
      ctx.strokeRect(
        viewCenterX - viewportWidth / 2,
        viewCenterY - viewportHeight / 2,
        viewportWidth,
        viewportHeight
      );

      ctx.restore();

      // Add click handler for mini-map re-centering
      canvas.addEventListener('click', handleMiniMapClick);
    }

    function handleMiniMapClick(event) {
      if (viewState.zoom <= viewState.minZoom) return;

      const miniSize = 150;
      const miniX = canvas.width - miniSize - 20;
      const miniY = 20;

      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      // Check if click is in mini-map
      if (clickX >= miniX && clickX <= miniX + miniSize &&
          clickY >= miniY && clickY <= miniY + miniSize) {

        // Convert click to map coordinates
        const miniPadding = 5;
        const miniScale = (miniSize - miniPadding * 2) / Math.max(viewState.mapBounds.width, viewState.mapBounds.height);
        const mapCenterX = (viewState.mapBounds.minX + viewState.mapBounds.maxX) / 2;
        const mapCenterY = (viewState.mapBounds.minY + viewState.mapBounds.maxY) / 2;

        const relX = (clickX - miniX - miniSize / 2) / miniScale;
        const relY = (clickY - miniY - miniSize / 2) / miniScale;
        const targetMapX = mapCenterX + relX;
        const targetMapY = mapCenterY + relY;

        // Update pan to center on clicked location
        viewState.panX = -(targetMapX - mapCenterX) * viewState.zoom;
        viewState.panY = -(targetMapY - mapCenterY) * viewState.zoom;

        renderMap();
        return;
      }
    }

    function handleCanvasClick(event) {
      // First check mini-map click
      if (viewState.zoom > viewState.minZoom) {
        const miniSize = 150;
        const miniX = canvas.width - miniSize - 20;
        const miniY = 20;
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        if (clickX >= miniX && clickX <= miniX + miniSize &&
            clickY >= miniY && clickY <= miniY + miniSize) {
          handleMiniMapClick(event);
          return;
        }
      }

      const rect = canvas.getBoundingClientRect();
      const screenX = event.clientX - rect.left;
      const screenY = event.clientY - rect.top;

      // Transform screen coordinates to map coordinates
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const mapCenterX = (viewState.mapBounds.minX + viewState.mapBounds.maxX) / 2;
      const mapCenterY = (viewState.mapBounds.minY + viewState.mapBounds.maxY) / 2;

      const x = ((screenX - centerX - viewState.panX) / viewState.zoom) + mapCenterX;
      const y = ((screenY - centerY - viewState.panY) / viewState.zoom) + mapCenterY;

      // Check if clicked on a node
      const clickRadius = 10 / viewState.zoom; // Adjust click radius based on zoom
      const clickedNode = gameState.nodes.find(node => {
        if (!node.location) return false;
        const dist = Math.sqrt(
          Math.pow(x - node.location[0], 2) +
          Math.pow(y - node.location[1], 2)
        );
        return dist < clickRadius;
      });

      if (clickedNode) {
        handleNodeClick(clickedNode);
        return;
      }

      // Check if clicked on an edge
      const clickedEdge = gameState.edges.find(edge => {
        const nodeA = gameState.nodes.find(n => n.id === edge.nodeA);
        const nodeB = gameState.nodes.find(n => n.id === edge.nodeB);

        if (!nodeA?.location || !nodeB?.location) return false;

        // Calculate distance from point to line segment
        const dist = pointToSegmentDistance(
          [x, y],
          nodeA.location,
          nodeB.location
        );
        return dist < clickRadius;
      });

      if (clickedEdge) {
        handleEdgeClick(clickedEdge);
      }
    }

    function pointToSegmentDistance(point, segStart, segEnd) {
      const [px, py] = point;
      const [x1, y1] = segStart;
      const [x2, y2] = segEnd;

      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSquared = dx * dx + dy * dy;

      if (lengthSquared === 0) {
        return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
      }

      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
      t = Math.max(0, Math.min(1, t));

      const nearestX = x1 + t * dx;
      const nearestY = y1 + t * dy;

      return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
    }

    function handleNodeClick(node) {
      const currentPlayer = Game.getCurrentPlayer(gameState);

      if (node.occupant?.playerId === currentPlayer.id && node.occupant.type === 'settlement') {
        // Try to upgrade to city
        const action = {
          type: 'upgradeToCity',
          playerId: currentPlayer.id,
          payload: { nodeId: node.id }
        };

        const validation = Game.validateAction(gameState, action);
        if (validation.ok) {
          gameState = Game.applyAction(gameState, action);
          updateUI();
          renderMap();
        } else {
          alert('Cannot upgrade to city: ' + validation.reason);
        }
      } else {
        // Try to place settlement
        const action = {
          type: 'placeSettlement',
          playerId: currentPlayer.id,
          payload: { nodeId: node.id }
        };

        const validation = Game.validateAction(gameState, action);
        if (validation.ok) {
          gameState = Game.applyAction(gameState, action);
          updateUI();
          renderMap();
        } else {
          alert('Cannot place settlement: ' + validation.reason);
        }
      }
    }

    function handleEdgeClick(edge) {
      const currentPlayer = Game.getCurrentPlayer(gameState);

      const action = {
        type: 'placeRoad',
        playerId: currentPlayer.id,
        payload: { edgeId: edge.id }
      };

      const validation = Game.validateAction(gameState, action);
      if (validation.ok) {
        gameState = Game.applyAction(gameState, action);
        updateUI();
        renderMap();
      } else {
        alert('Cannot place road: ' + validation.reason);
      }
    }

    function handleRollDice() {
      if (gameState.phase === 'setup') {
        alert('Cannot roll dice during setup phase');
        return;
      }

      const roll = Game.rollDice();
      document.getElementById('diceResult').textContent = `üé≤ Rolled: ${roll}`;

      if (roll === 7) {
        gameState = Game.handleRobberActivation(gameState);
        alert('Rolled a 7! Players with >7 cards must discard. Move the robber!');
      } else {
        gameState = Game.collectResources(gameState, roll);
      }

      updateUI();
      renderMap();
    }

    function handleEndTurn() {
      const action = {
        type: 'endTurn',
        playerId: Game.getCurrentPlayer(gameState).id,
        payload: {}
      };

      gameState = Game.applyAction(gameState, action);
      document.getElementById('diceResult').textContent = '';
      updateUI();
      renderMap();
    }
  </script>
</body>
</html>
