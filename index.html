<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Natac - Catan-like Polygon Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .header p {
      opacity: 0.9;
      font-size: 1.1rem;
    }

    .setup-screen {
      padding: 40px;
    }

    .setup-section {
      margin-bottom: 30px;
    }

    .setup-section h2 {
      margin-bottom: 15px;
      color: #333;
    }

    .map-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .map-option {
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .map-option:hover {
      border-color: #667eea;
      background: #f8f9ff;
      transform: translateY(-2px);
    }

    .map-option.selected {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .map-option h3 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .map-option p {
      color: #666;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .player-setup {
      margin-top: 20px;
    }

    .player-inputs {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .player-input {
      display: flex;
      flex-direction: column;
    }

    .player-input label {
      margin-bottom: 5px;
      font-weight: 500;
      color: #555;
    }

    .player-input input {
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
    }

    .player-input input:focus {
      outline: none;
      border-color: #667eea;
    }

    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 1.1rem;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
      margin-top: 20px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .game-screen {
      display: none;
      padding: 20px;
    }

    .game-layout {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
    }

    .sidebar {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      height: fit-content;
    }

    .player-info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border-left: 4px solid #667eea;
    }

    .player-info.current {
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .player-info h3 {
      margin-bottom: 10px;
      color: #333;
    }

    .resource-list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      font-size: 0.9rem;
      color: #666;
    }

    .canvas-container {
      background: white;
      border-radius: 12px;
      padding: 20px;
      position: relative;
      overflow: auto;
    }

    #gameCanvas {
      display: block;
      margin: 0 auto;
      cursor: crosshair;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .controls button {
      padding: 10px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
    }

    .controls button:hover {
      background: #5568d3;
    }

    .controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .info-panel {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .resource-display {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .resource-item {
      padding: 8px 15px;
      background: white;
      border-radius: 6px;
      font-size: 0.9rem;
      border: 1px solid #e0e0e0;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé≤ Natac</h1>
      <p>A Catan-like game on arbitrary polygon maps</p>
    </div>

    <div id="setupScreen" class="setup-screen">
      <div class="setup-section">
        <h2>Choose Your Map</h2>
        <div class="map-options">
          <div class="map-option selected" data-map-type="standard">
            <h3>Standard Catan Map</h3>
            <p>Classic 19-hex Catan board with standard resource distribution</p>
          </div>
          <div class="map-option" data-map-type="expanded-hex">
            <h3>Expanded Hex Grid</h3>
            <p>Larger hexagonal map with more tiles for extended gameplay</p>
          </div>
          <div class="map-option" data-map-type="expanded-delaunay">
            <h3>Delaunay Polygon Map</h3>
            <p>Organic-looking irregular polygons using Delaunay-centroid algorithm</p>
          </div>
        </div>
      </div>

      <div class="setup-section">
        <h2>Players</h2>
        <div class="player-setup">
          <div class="player-inputs">
            <div class="player-input">
              <label>Player 1</label>
              <input type="text" id="player1" value="Alice" />
            </div>
            <div class="player-input">
              <label>Player 2</label>
              <input type="text" id="player2" value="Bob" />
            </div>
            <div class="player-input">
              <label>Player 3</label>
              <input type="text" id="player3" value="Charlie" />
            </div>
            <div class="player-input">
              <label>Player 4 (Optional)</label>
              <input type="text" id="player4" placeholder="Optional" />
            </div>
          </div>
        </div>
      </div>

      <button class="btn" id="startGameBtn">Start Game</button>
    </div>

    <div id="gameScreen" class="game-screen">
      <div class="game-layout">
        <div class="sidebar">
          <h2 style="margin-bottom: 15px;">Players</h2>
          <div id="playerList"></div>

          <div id="currentPlayerInfo" class="info-panel" style="margin-top: 20px;">
            <h3 style="margin-bottom: 10px;">Current Turn</h3>
            <p id="currentPlayerText">-</p>
          </div>

          <div class="controls">
            <button id="rollDiceBtn">Roll Dice</button>
            <button id="endTurnBtn">End Turn</button>
          </div>

          <div id="diceResult" style="margin-top: 15px; font-size: 1.2rem; font-weight: bold;"></div>
        </div>

        <div class="canvas-container">
          <div id="mapInfo" class="info-panel">
            <strong>Map Type:</strong> <span id="mapTypeDisplay">-</span><br>
            <strong>Tiles:</strong> <span id="tileCount">-</span> |
            <strong>Nodes:</strong> <span id="nodeCount">-</span> |
            <strong>Edges:</strong> <span id="edgeCount">-</span>
          </div>
          <canvas id="gameCanvas" width="900" height="700"></canvas>
          <div id="clickInfo" style="margin-top: 10px; font-size: 0.9rem; color: #666;">
            Click on nodes to place settlements, click on edges to place roads
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Include map generation module -->
  <script src="./src/mapgen.js"></script>

  <script type="module">
    // This will be populated with the compiled game logic
    import * as Game from './dist/index.js';

    let gameState = null;
    let selectedMapType = 'standard';
    let canvas, ctx;

    // Setup screen event listeners
    document.querySelectorAll('.map-option').forEach(option => {
      option.addEventListener('click', () => {
        document.querySelectorAll('.map-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedMapType = option.dataset.mapType;
      });
    });

    document.getElementById('startGameBtn').addEventListener('click', startGame);

    function startGame() {
      const playerNames = [
        document.getElementById('player1').value,
        document.getElementById('player2').value,
        document.getElementById('player3').value,
        document.getElementById('player4').value
      ].filter(name => name.trim() !== '');

      if (playerNames.length < 2) {
        alert('Please enter at least 2 player names');
        return;
      }

      const options = {
        mapType: selectedMapType,
        enhancedKnights: true,
        seed: Date.now(),
        expandedMapSize: 30,
        delaunayTileCount: 30
      };

      try {
        gameState = Game.createGame(playerNames, options);
        console.log('Game created:', gameState);

        document.getElementById('setupScreen').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';

        initializeCanvas();
        updateUI();
        renderMap();
      } catch (error) {
        alert('Error creating game: ' + error.message);
        console.error(error);
      }
    }

    function initializeCanvas() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      canvas.addEventListener('click', handleCanvasClick);

      // Update map info
      document.getElementById('mapTypeDisplay').textContent = selectedMapType;
      document.getElementById('tileCount').textContent = gameState.tiles.length;
      document.getElementById('nodeCount').textContent = gameState.nodes.length;
      document.getElementById('edgeCount').textContent = gameState.edges.length;
    }

    function updateUI() {
      const playerList = document.getElementById('playerList');
      playerList.innerHTML = '';

      gameState.players.forEach((player, idx) => {
        const isCurrent = idx === gameState.currentPlayerIdx;
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-info' + (isCurrent ? ' current' : '');

        const resources = Object.entries(player.resources)
          .filter(([res]) => res !== 'desert')
          .map(([res, count]) => `${res}: ${count}`)
          .join(', ');

        playerDiv.innerHTML = `
          <h3>${player.name} ${isCurrent ? '‚≠ê' : ''}</h3>
          <div style="margin-bottom: 10px;">
            <strong>VP:</strong> ${player.victoryPoints} |
            <strong>Settlements:</strong> ${player.settlements.length} |
            <strong>Cities:</strong> ${player.cities.length}
          </div>
          <div class="resource-display">
            ${Object.entries(player.resources)
              .filter(([res]) => res !== 'desert')
              .map(([res, count]) => `<div class="resource-item">${res}: ${count}</div>`)
              .join('')}
          </div>
        `;

        playerList.appendChild(playerDiv);
      });

      const currentPlayer = Game.getCurrentPlayer(gameState);
      document.getElementById('currentPlayerText').textContent =
        `${currentPlayer.name}'s turn (${gameState.phase === 'setup' ? 'Setup' : 'Main'} phase)`;

      // Setup event listeners
      document.getElementById('rollDiceBtn').onclick = handleRollDice;
      document.getElementById('endTurnBtn').onclick = handleEndTurn;
    }

    function renderMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Center and scale the map
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      ctx.save();
      ctx.translate(centerX, centerY);

      // Draw tiles
      gameState.tiles.forEach(tile => {
        if (!tile.polygonPoints || tile.polygonPoints.length === 0) return;

        ctx.beginPath();
        ctx.moveTo(tile.polygonPoints[0][0], tile.polygonPoints[0][1]);
        for (let i = 1; i < tile.polygonPoints.length; i++) {
          ctx.lineTo(tile.polygonPoints[i][0], tile.polygonPoints[i][1]);
        }
        ctx.closePath();

        // Fill based on resource
        const colors = {
          wood: '#228B22',
          brick: '#A0522D',
          sheep: '#90EE90',
          wheat: '#FFD700',
          ore: '#708090',
          desert: '#DEB887'
        };
        ctx.fillStyle = colors[tile.resource] || '#ccc';
        ctx.fill();

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw dice number
        if (tile.diceNumber) {
          const center = tile.polygonPoints.reduce(
            (acc, p) => [acc[0] + p[0], acc[1] + p[1]],
            [0, 0]
          );
          center[0] /= tile.polygonPoints.length;
          center[1] /= tile.polygonPoints.length;

          ctx.fillStyle = tile.robberPresent ? 'red' : 'white';
          ctx.beginPath();
          ctx.arc(center[0], center[1], 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.fillStyle = '#000';
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.diceNumber.toString(), center[0], center[1]);
        }

        // Draw robber indicator
        if (tile.robberPresent) {
          const center = tile.polygonPoints.reduce(
            (acc, p) => [acc[0] + p[0], acc[1] + p[1]],
            [0, 0]
          );
          center[0] /= tile.polygonPoints.length;
          center[1] /= tile.polygonPoints.length;

          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.beginPath();
          ctx.arc(center[0], center[1] + 25, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Draw edges (roads)
      gameState.edges.forEach(edge => {
        const nodeA = gameState.nodes.find(n => n.id === edge.nodeA);
        const nodeB = gameState.nodes.find(n => n.id === edge.nodeB);

        if (!nodeA?.location || !nodeB?.location) return;

        ctx.beginPath();
        ctx.moveTo(nodeA.location[0], nodeA.location[1]);
        ctx.lineTo(nodeB.location[0], nodeB.location[1]);

        if (edge.roadOwner) {
          const owner = gameState.players.find(p => p.id === edge.roadOwner);
          ctx.strokeStyle = owner?.color || '#000';
          ctx.lineWidth = 5;
        } else {
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.lineWidth = 1;
        }

        ctx.stroke();
      });

      // Draw nodes (settlements/cities)
      gameState.nodes.forEach(node => {
        if (!node.location) return;

        ctx.beginPath();
        ctx.arc(node.location[0], node.location[1], 6, 0, Math.PI * 2);

        if (node.occupant) {
          const owner = gameState.players.find(p => p.id === node.occupant.playerId);
          ctx.fillStyle = owner?.color || '#000';
          if (node.occupant.type === 'city') {
            ctx.arc(node.location[0], node.location[1], 10, 0, Math.PI * 2);
          }
        } else {
          ctx.fillStyle = 'white';
        }

        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      ctx.restore();
    }

    function handleCanvasClick(event) {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left - canvas.width / 2;
      const y = event.clientY - rect.top - canvas.height / 2;

      // Check if clicked on a node
      const clickedNode = gameState.nodes.find(node => {
        if (!node.location) return false;
        const dist = Math.sqrt(
          Math.pow(x - node.location[0], 2) +
          Math.pow(y - node.location[1], 2)
        );
        return dist < 10;
      });

      if (clickedNode) {
        handleNodeClick(clickedNode);
        return;
      }

      // Check if clicked on an edge
      const clickedEdge = gameState.edges.find(edge => {
        const nodeA = gameState.nodes.find(n => n.id === edge.nodeA);
        const nodeB = gameState.nodes.find(n => n.id === edge.nodeB);

        if (!nodeA?.location || !nodeB?.location) return false;

        // Calculate distance from point to line segment
        const dist = pointToSegmentDistance(
          [x, y],
          nodeA.location,
          nodeB.location
        );
        return dist < 10;
      });

      if (clickedEdge) {
        handleEdgeClick(clickedEdge);
      }
    }

    function pointToSegmentDistance(point, segStart, segEnd) {
      const [px, py] = point;
      const [x1, y1] = segStart;
      const [x2, y2] = segEnd;

      const dx = x2 - x1;
      const dy = y2 - y1;
      const lengthSquared = dx * dx + dy * dy;

      if (lengthSquared === 0) {
        return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
      }

      let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
      t = Math.max(0, Math.min(1, t));

      const nearestX = x1 + t * dx;
      const nearestY = y1 + t * dy;

      return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
    }

    function handleNodeClick(node) {
      const currentPlayer = Game.getCurrentPlayer(gameState);

      if (node.occupant?.playerId === currentPlayer.id && node.occupant.type === 'settlement') {
        // Try to upgrade to city
        const action = {
          type: 'upgradeToCity',
          playerId: currentPlayer.id,
          payload: { nodeId: node.id }
        };

        const validation = Game.validateAction(gameState, action);
        if (validation.ok) {
          gameState = Game.applyAction(gameState, action);
          updateUI();
          renderMap();
        } else {
          alert('Cannot upgrade to city: ' + validation.reason);
        }
      } else {
        // Try to place settlement
        const action = {
          type: 'placeSettlement',
          playerId: currentPlayer.id,
          payload: { nodeId: node.id }
        };

        const validation = Game.validateAction(gameState, action);
        if (validation.ok) {
          gameState = Game.applyAction(gameState, action);
          updateUI();
          renderMap();
        } else {
          alert('Cannot place settlement: ' + validation.reason);
        }
      }
    }

    function handleEdgeClick(edge) {
      const currentPlayer = Game.getCurrentPlayer(gameState);

      const action = {
        type: 'placeRoad',
        playerId: currentPlayer.id,
        payload: { edgeId: edge.id }
      };

      const validation = Game.validateAction(gameState, action);
      if (validation.ok) {
        gameState = Game.applyAction(gameState, action);
        updateUI();
        renderMap();
      } else {
        alert('Cannot place road: ' + validation.reason);
      }
    }

    function handleRollDice() {
      if (gameState.phase === 'setup') {
        alert('Cannot roll dice during setup phase');
        return;
      }

      const roll = Game.rollDice();
      document.getElementById('diceResult').textContent = `üé≤ Rolled: ${roll}`;

      if (roll === 7) {
        gameState = Game.handleRobberActivation(gameState);
        alert('Rolled a 7! Players with >7 cards must discard. Move the robber!');
      } else {
        gameState = Game.collectResources(gameState, roll);
      }

      updateUI();
      renderMap();
    }

    function handleEndTurn() {
      const action = {
        type: 'endTurn',
        playerId: Game.getCurrentPlayer(gameState).id,
        payload: {}
      };

      gameState = Game.applyAction(gameState, action);
      document.getElementById('diceResult').textContent = '';
      updateUI();
      renderMap();
    }
  </script>
</body>
</html>
